/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package apachebeamtraining;

import org.apache.beam.sdk.Pipeline;
import org.apache.beam.sdk.io.TextIO;
import org.apache.beam.sdk.options.PipelineOptions;
import org.apache.beam.sdk.options.PipelineOptionsFactory;
import org.apache.beam.sdk.transforms.DoFn;
import org.apache.beam.sdk.transforms.GroupByKey;
import org.apache.beam.sdk.transforms.ParDo;
import org.apache.beam.sdk.values.KV;
import org.apache.beam.sdk.values.PCollection;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class App {

    private static Logger logger = LoggerFactory.getLogger(App.class);

    /*
     * Extract 5th field of the input text.
     */
    public static class ExtractAmountFromRowFn extends DoFn<String, String> {
        @ProcessElement
        public void process(ProcessContext c) {

            try {
                String row = c.element();

                String[] cells = row.split(",");

                c.output(cells[4]);
            } catch (java.lang.ArrayIndexOutOfBoundsException e) {
                logger.error("Failed to process data", e);
            }
        }
    }

    /**
     * KV<String, Iterable<Integer> -> String
     */
    static class ConvertKVToStringFn extends DoFn<KV<String, Iterable<Integer>>, String> {
        @ProcessElement
        public void processElement(ProcessContext c) {

            c.output(String.valueOf(c.element()));

        }

    }

    /*
     * String -> KV<String, Integer>
     */
    static class ConvertStringIntoKVFn extends DoFn<String, KV<String, Integer>> {
        @ProcessElement
        public void processElement(ProcessContext c) {
            String row = c.element();
            String[] cells = row.split(",");
            c.output(KV.of(cells[0], row.length()));
        }
    }

    public static void main(String[] args) {

        PipelineOptions options = PipelineOptionsFactory.create();

        Pipeline p = Pipeline.create(options);

        // Input: read from file
        PCollection<String> textData = p.apply(TextIO.read().from("input-record.txt"));

        // Process1: Group by the cryptocurrency name and write each line length to the file.
        PCollection<KV<String, Integer>> mapped =
                textData.apply(ParDo.of(new ConvertStringIntoKVFn()));
        PCollection<KV<String, Iterable<Integer>>> groupByKey =
                mapped.apply(GroupByKey.<String, Integer>create());
        PCollection<String> count = groupByKey.apply(ParDo.of(new ConvertKVToStringFn()));
        count.apply(TextIO.write().to("output-aggregated"));

        // Process2: Extract the amount of each line and write it to the file.
        PCollection<String> bidData = textData.apply(ParDo.of(new ExtractAmountFromRowFn()));
        bidData.apply(TextIO.write().to("output-map"));

        p.run().waitUntilFinish();
    }
}
