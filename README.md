# Apache Beam Training

## Versions

- Java: 11 (18 not supported)
- Gradle: 7.5.1

## How to run

```
./gradlew run
```

## Development

### 1. First Apache Beam Application

<details><summary>First Apache Beam Application</summary>

1. Update `app/build.gradle.kts`.

    ```kotlin
    /*
     * This file was generated by the Gradle 'init' task.
     *
     * This generated file contains a sample Java application project to get you started.
     * For more details take a look at the 'Building Java & JVM projects' chapter in the Gradle
     * User Manual available at https://docs.gradle.org/7.5.1/userguide/building_java_projects.html
     */

    plugins {
        // Apply the application plugin to add support for building a CLI application in Java.
        application
    }

    repositories {
        // Use Maven Central for resolving dependencies.
        mavenCentral()

        maven {
            url = uri("https://packages.confluent.io/maven/")
        }
    }

    dependencies {
        // Use JUnit Jupiter for testing.
        testImplementation("org.junit.jupiter:junit-jupiter:5.8.2")

        // This dependency is used by the application.
        implementation("com.google.guava:guava:31.0.1-jre")

        // https://mvnrepository.com/artifact/org.apache.beam/beam-sdks-java-core
        implementation("org.apache.beam:beam-sdks-java-core:2.41.0")

        // https://mvnrepository.com/artifact/org.apache.beam/beam-runners-direct-java
        runtimeOnly("org.apache.beam:beam-runners-direct-java:2.41.0")

    }

    application {
        // Define the main class for the application.
        mainClass.set("apachebeamtraining.App")
    }

    tasks.named<Test>("test") {
        // Use JUnit Platform for unit tests.
        useJUnitPlatform()
    }

    if (project.hasProperty("dataflow-runner")) {
        dependencies {
            runtimeOnly("org.apache.beam:beam-runners-google-cloud-dataflow-java:2.41.0")
        }
    }

    task("execute", JavaExec::class) {
        classpath = sourceSets["main"].runtimeClasspath
        mainClass.set(System.getProperty("mainClass"))
    }
    ```

1. Create a Apache Beam pipeline in `main` function.

    ```java
    PipelineOptions options = PipelineOptionsFactory.create();
    // Create pipeline
    Pipeline p = Pipeline.create(options);
    // Read text data from Sample.txt
    PCollection<String> textData = p.apply(TextIO.read().from("Sample.txt"));
    // Write to the output file with wordcounts as a prefix
    textData.apply(TextIO.write().to("wordcounts"));
    // Run the pipeline
    p.run().waitUntilFinish();
    ```

1. Prepare `app/Sample.txt` file. (You can write anything in the file.)
1. Run

    ```
    ./gradlew run
    ```

    You'll see `wordcounts-*` files under `app` directory.

</details>

### 2. ParDo and DoFn: Parallel processing

- [ParDo](https://beam.apache.org/documentation/programming-guide/#pardo): a Beam transform for generic parallel processing.
- **DoFn**: When you apply a ParDo transform, youâ€™ll need to provide user code in the form of a DoFn object. DoFn is a Beam SDK class that defines a distributed processing function.

<details><summary>ParDo and DoFn: Parallel processing</summary>

1. Change the input data `app/input-record.txt`.

    ```
    BTC/JPY,bitflyer,1519845731987,1127174.0,1126166.0
    BTC/JPY,bitflyer,1519845742363,1127470.0,1126176.0
    BTC/JPY,bitflyer,1519845752427,1127601.0,1126227.0
    BTC/JPY,bitflyer,1519845762038,1127591.0,1126316.0
    BTC/JPY,bitflyer,1519845772637,1127801.0,1126368.0
    BTC/JPY,bitflyer,1519845782073,1126990.0,1126411.0
    BTC/JPY,bitflyer,1519845792827,1127990.0,1126457.0
    BTC/JPY,bitflyer,1519845802008,1127980.0,1126500.0
    BTC/JPY,bitflyer,1519845812088,1127980.0,1126566.0
    BTC/JPY,bitflyer,1519845822743,1127970.0,1126601.0
    ```

1. Add `transform` step with `ParDo` to the pipeline.
    ```java
    PCollection<String> textData = p.apply(TextIO.read().from("input-record.txt"));

    PCollection<String> bidData = textData.apply(ParDo.of(new ExtractBid()));

    bidData.apply(TextIO.write().to("output")); // just changed the name of PCollection and the prefix of output files
    ```
1. Define `DoFn` `ExtractBid`.

    1. extends `DoFn<String, String>` (`<String, String>` means the input and the output are both `String`)
    1. [`@ProcessElement` annotation](https://beam.apache.org/releases/javadoc/2.3.0/org/apache/beam/sdk/transforms/DoFn.ProcessElement.html) is necessary.

    ```java
    public static class ExtractBid extends DoFn<String, String> {
        @ProcessElement
        public void process(ProcessContext c){

            String row = c.element();

            String[] cells = row.split(",");
            c.output(cells[4]);
        }
    }
    ```

1. Run the app

    ```
    ./gradlew run
    ```

    You'll see output files `output-*` with only the 5th field as their contents. (Multiple files are generated as they are processed in parallel.)

</details>

### 3. KV + GroupByKey: Aggregation

- [KV](https://beam.apache.org/releases/javadoc/2.2.0/index.html?org/apache/beam/sdk/values/KV.html): An immutable key value pair
- [GroupByKey](https://beam.apache.org/documentation/programming-guide/#groupbykey): a Beam transform for processing collections of key/value pairs.

<details>

1. Convert `PCollection<Stringe>` into [KV](https://beam.apache.org/releases/javadoc/2.0.0/org/apache/beam/sdk/values/KV.html) with **SimpleFunction** ([Simple case of DoFn](https://stackoverflow.com/questions/50525766/apache-beam-what-is-the-difference-between-dofn-and-simplefunction)). (use the first column for the key)

    ```java
    PCollection<KV<String, Integer>> mapped =
    textData.apply(MapElements.via(new SimpleFunction<String, KV<String, Integer>>() {
        @Override
        public KV<String, Integer> apply(String line) {
            String[] cells = line.split(",");

            return KV.of(cells[0], line.length());
        }
    }));
    ```

1. `GroupByKey`: Group by the first column of the input.
    ```java
    PCollection<KV<String, Iterable<Integer>>> groupByKey = mapped.apply(GroupByKey.<String, Integer>create());
    ```
1. Convert the `PCollection<KV<String, Iterable<Integer>>>` into `PCollection<String>` just to write to output file.
    ```java
    PCollection<String> count = groupByKey.apply(ParDo.of(new ConvertKVToStringFn()));
    ```

    `ConvertKVToStringFn`:
    ```java
    /**
     * KV<String, Iterable<Integer> -> String
     */
    static class ConvertKVToStringFn extends DoFn<KV<String, Iterable<Integer>>, String> {
        @ProcessElement
        public void processElement(ProcessContext c) {
            c.output(String.valueOf(c.element()));
        }
    }
    ```

1. Write to output file.

    Input file is changed to have multiple keys:

    ```
    cat app/output-aggregated-0000*
    KV{BTC/JPY, [50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50]}
    KV{wronglyformatedrecord, [21]}
    KV{ETH/JPY, [50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50]}
    ```

</details>

### 4. MapElement.via(new SimpleFunction) <-> ParDo + DoFn

<details><summary>ConvertStringIntoKVFn</summary>

`MapElement.via(new SimpleFunction)`:

```java
PCollection<KV<String, Integer>> mapped =
textData.apply(MapElements.via(new SimpleFunction<String, KV<String, Integer>>() {
    @Override
    public KV<String, Integer> apply(String line) {
        String[] cells = line.split(",");

        return KV.of(cells[0], line.length());
    }
}));
```

`ParDo` + `DoFn`:

```java
    /*
     * String -> KV<String, Integer>
     */
    static class ConvertStringIntoKVFn extends DoFn<String, KV<String, Integer>> {
        @ProcessElement
        public void processElement(ProcessContext c) {
            String row = c.element();
            String[] cells = row.split(",");
            c.output(KV.of(cells[0], row.length()));
        }
    }
```

and

```java
PCollection<KV<String, Integer>> mapped = textData.apply(ParDo.of(new ConvertStringIntoKVFn()));
```

</details>


<details><summary>ConvertKVToStringFn</summary>

`SimpleFunction`:

```java
PCollection<String> count = groupByKey.apply(MapElements.via(new SimpleFunction<KV<String, Iterable<Integer>>, String>() {
            @Override
            public String apply(KV<String, Iterable<Integer>> kv) {
                return String.valueOf(kv);
            }
        }));
```

`ConvertKVToStringFn` (ParDo + DoFn):

```java
/**
 * KV<String, Iterable<Integer> -> String
 */
static class ConvertKVToStringFn extends DoFn<KV<String, Iterable<Integer>>, String> {
    @ProcessElement
    public void processElement(ProcessContext c) {
        c.output(String.valueOf(c.element()));
    }
}
```

</details>

### 5. KV with custom class and GroupIntoBatches

- [GroupIntoBatches](https://beam.apache.org/releases/javadoc/2.0.0/org/apache/beam/sdk/transforms/GroupIntoBatches.html): A PTransform that batches inputs to a desired batch size. Batches will contain only elements of a single key.

<details><summary>GroupIntoBatches</summary>

1. Create `CryptoCurrency`

    ```java
    package apachebeamtraining;

    import java.io.Serializable;

    public class CryptoCurrency implements Serializable {

      private String name;
      private long amount;

      public CryptoCurrency(String name, long amount) {
        this.name = name;
        this.amount = amount;
      }

      public long getAmount() {
        return amount;
      }

      public String toString() {
        return String.format("name:%s amount:%d", name, amount);
      }
    }
    ```

1. Convert text into `KV<String, CryptoCurrency>`

    ```java
    /*
     * String -> KV<String, CryptoCurrency>
     */
    static class ConvertTextIntoKVCryptoCurrencyFn
            extends DoFn<String, KV<String, CryptoCurrency>> {
        @ProcessElement
        public void processElement(@Element String row,
                OutputReceiver<KV<String, CryptoCurrency>> receiver) {
            String[] cells = row.split(",");
            try {
                double amount = Double.parseDouble(cells[4]);
                receiver.output(KV.of(cells[0], new CryptoCurrency(cells[0], amount)));
            } catch (NumberFormatException ex) {
                logger.error("failed to convert to CryptoCurrency", ex);
            } catch (ArrayIndexOutOfBoundsException ex) {
                logger.error("failed to convert to CryptoCurrency", ex);
            }
        }
    }
    ```

    ```java
    PCollection<KV<String, CryptoCurrency>> cryptoKV =
            textData.apply(ParDo.of(new ConvertTextIntoKVCryptoCurrencyFn()));
    ```

1. Prepare `BatchResult`
    ```java
    package apachebeamtraining;

    import java.text.SimpleDateFormat;
    import java.util.Date;

    public class BatchResult {
      private int count;
      private String key;
      private Date completedAt;
      private SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd 'at' HH:mm:sss z");

      public BatchResult(String key, int count, Date completedAt) {
        this.key = key;
        this.count = count;
        this.completedAt = completedAt;
      }

      public String toString() {
        return String.format("key:%s, count:%d, completedAt:%s", key, count,
            formatter.format(completedAt));
      }
    }
    ```
1. Group into batches.
    ```java
    PCollection<KV<String, Iterable<CryptoCurrency>>> batchedCrypt =
            cryptoKV.apply(GroupIntoBatches.<String, CryptoCurrency>ofSize(3));
    ```
1. Process batches (`KV<String, Iterable<CryptoCurrency>>`)

    ```java
    /*
     * Process item in a batch. Just count the number of item and return BatchResult as String.
     */
    static class ProcessBatch extends DoFn<KV<String, Iterable<CryptoCurrency>>, String> {
        @ProcessElement
        public void process(OutputReceiver<String> receiver,
                @Element KV<String, Iterable<CryptoCurrency>> batch) {
            int count = 0;
            Iterator<CryptoCurrency> iter = batch.getValue().iterator();
            while (iter.hasNext()) {
                count++;
            }
            receiver.output(String.valueOf(count));
        }
    }
    ```

    ```java
    batchedCrypt.apply(ParDo.of(new ProcessBatch())).apply(TextIO.write().to("output-count"));
    ```

1. Run `./gradlew run`

    You can confirm the batch process result:
    ```
    cat app/output-count-*
    key:BTC/JPY, count:3, completedAt:2022-09-02 at 16:20:054 JST
    key:BTC/JPY, count:3, completedAt:2022-09-02 at 16:20:054 JST
    key:BTC/JPY, count:3, completedAt:2022-09-02 at 16:20:054 JST
    key:BTC/JPY, count:3, completedAt:2022-09-02 at 16:20:054 JST
    key:ETH/JPY, count:3, completedAt:2022-09-02 at 16:20:054 JST
    key:BTC/JPY, count:3, completedAt:2022-09-02 at 16:20:055 JST
    key:ETH/JPY, count:3, completedAt:2022-09-02 at 16:20:054 JST
    key:BTC/JPY, count:3, completedAt:2022-09-02 at 16:20:054 JST
    key:ETH/JPY, count:3, completedAt:2022-09-02 at 16:20:054 JST
    key:ETH/JPY, count:3, completedAt:2022-09-02 at 16:20:055 JST
    key:BTC/JPY, count:3, completedAt:2022-09-02 at 16:20:055 JST
    key:ETH/JPY, count:3, completedAt:2022-09-02 at 16:20:055 JST
    key:BTC/JPY, count:3, completedAt:2022-09-02 at 16:20:054 JST
    key:ETH/JPY, count:1, completedAt:2022-09-02 at 16:20:055 JST
    ```

</details>


# References

1. https://www.youtube.com/c/ApacheBeamYT/videos
1. https://medium.com/@vallerylancey/error-handling-elements-in-apache-beam-pipelines-fffdea91af2a
